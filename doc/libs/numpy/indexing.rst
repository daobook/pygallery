.. for doctest:
    >>> import numpy as np
  
.. _basics.indexing:
****************************************
对 :class:`ndarrays <.ndarray>` 的索引
****************************************

.. seealso::

   :ref:`索引函数 <routines.indexing>`

.. sectionauthor:: 改编自 "NumPy 指南" 作者 Travis E. Oliphant

.. currentmodule:: numpy

.. index:: 索引, 切片

:class:`ndarrays <ndarray>` 可以使用标准的 Python 语法 ``x[obj]`` 进行索引，其中 *x* 是数组，*obj* 是选择对象。根据 *obj* 的不同，有多种索引方式可供选择：基本索引、高级索引和字段访问。

以下大多数示例展示了在引用数组中的数据时使用索引的情况。这些示例在赋值给数组时也同样适用。有关赋值的具体示例和解释，请参阅 :ref:`向索引数组赋值`。

请注意，在 Python 中，``x[(exp1, exp2, ..., expN)]`` 等价于 ``x[exp1, exp2, ..., expN]``；后者只是前者的语法糖。

.. _basic-indexing:

基本索引
--------

.. _single-element-indexing:

单元素索引
~~~~~~~~~~

单元素索引的工作方式与其他标准 Python 序列完全相同。它是基于 0 的索引，并且接受负索引从数组的末尾进行索引。

>>> x = np.arange(10)
>>> x[2]
2
>>> x[-2]
8

不需要将每个维度的索引分开到各自的方括号中。

>>> x.shape = (2, 5)  # 现在 x 是二维的
>>> x[1, 3]
8
>>> x[1, -1]
9


请注意，如果用少于维度数的索引对多维数组进行索引，则会得到一个子维度数组。例如：


>>> x[0]
array([0, 1, 2, 3, 4])


也就是说，每个指定的索引选择与所选维度对应的数组。在上面的例子中，选择 0 意味着长度为 5 的剩余维度未被指定，返回的是一个具有该维度和尺寸的数组。需要注意的是，返回的数组是一个 :term:`视图`，即它不是原始数组的副本，而是指向与原始数组相同的内存中的值。在这种情况下，返回的是第一个位置（0）上的 1 维数组。因此，对返回的数组使用单个索引，将返回一个单个元素。即：


>>> x[0][2]
2

因此，请注意 ``x[0, 2] == x[0][2]``，尽管第二种情况效率较低，因为在第一个索引之后会创建一个新的临时数组，然后由 2 进行索引。

.. note::

    NumPy 使用 C 风格的索引。这意味着最后一个索引通常表示内存中变化最快的部分，这与 Fortran 或 IDL 不同，在 Fortran 或 IDL 中，第一个索引表示内存中变化最快的部分。这种差异代表着巨大的混淆潜力。

.. _slicing-and-striding:

切片和跨步
~~~~~~~~~~~~

基本切片将Python的基本切片概念扩展到N维。当 *obj* 是 :class:`slice` 对象（通过方括号内的 ``start:stop:step`` 表示法构造）、一个整数或一个由切片对象和整数组成的元组时，会发生基本切片。:py:data:`Ellipsis` 和 :const:`newaxis` 对象也可以与这些对象混合使用。

.. index::
   三元组: ndarray; 特殊方法; getitem
   三元组: ndarray; 特殊方法; setitem
   单个: ellipsis
   单个: newaxis

用*N*个整数进行索引的最简单情况是返回 :ref:`数组标量 <arrays.scalars>`，表示相应的项。与Python一样，所有索引都是从零开始的：对于第 *i* 个索引 :math:`n_i`，有效范围是 :math:`0 \le n_i < d_i`，其中 :math:`d_i` 是数组形状的第 *i* 个元素。负索引被解释为从数组末尾开始计数（即，如果 :math:`n_i < 0`，它表示 :math:`n_i + d_i`）。

通过基本切片生成的所有数组始终是原始数组的 :term:`视图 <view>`。

.. note::

    NumPy切片创建 :term:`视图`，而不是像字符串、元组和列表等内置Python序列那样创建副本。在从一个大的数组中提取一小部分时需要小心，因为提取的部分包含对原始大数组的引用，直到从它派生的所有数组都被垃圾回收之前，原始数组的内存不会被释放。在这种情况下，建议显式使用 ``copy()``。

序列切片的标准规则适用于按维度进行的基本切片（包括使用步长索引）。一些需要记住的有用概念包括：

- 基本切片语法是 ``i:j:k``，其中 *i* 是起始索引，*j* 是停止索引，*k* 是步长（ :math:`k\neq0`）。这会选择具有索引值 *i*、 *i + k*、...、 *i + (m - 1) k* 的 *m* 个元素（在相应的维度中），其中 :math:`m = q + (r\neq0)`，*q* 和 *r* 是通过将 *j - i* 除以 *k* 得到的商和余数： *j - i = q k + r*，因此 *i + (m - 1) k < j*。例如::

     >>> x = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
     >>> x[1:7:2]
     array([1, 3, 5])

- 负的 *i* 和 *j* 被解释为 *n + i* 和 *n + j*，其中 *n* 是相应维度中的元素数量。负的 *k* 使步长向较小的索引方向移动。从上面的例子::

      >>> x[-2:10]
      array([8, 9])
      >>> x[-3:3:-1]
      array([7, 6, 5, 4])

- 假设 *n* 是正在切片的维度中的元素数量。那么，如果 *i* 未给出，它默认为0（对于 *k > 0*）和 *n - 1* （对于 *k < 0*）。如果 *j* 未给出，它默认为 *n*（对于 *k > 0*）和 *-n-1*（对于 *k < 0*）。如果 *k* 未给出，它默认为1。注意，``::`` 与 ``:`` 相同，表示选择该轴上的所有索引。从上面的例子::

      >>> x[5:]
      array([5, 6, 7, 8, 9])

- 如果选择元组中的对象数量少于 *N*，则假设后续维度为 ``:``。例如::

      >>> x = np.array([[[1],[2],[3]], [[4],[5],[6]]])
      >>> x.shape
      (2, 3, 1)
      >>> x[1:2]
      array([[[4],
              [5],
              [6]]])

- 一个整数 *i* 返回与 ``i:i+1`` 相同的值，**除了** 返回对象的维度减少1。特别是，一个选择元组，其中第 *p* 个元素是整数（所有其他条目为``:``），返回相应子数组，维度为 *N - 1*。如果 *N = 1*，则返回的对象是数组标量。这些对象在 :ref:`arrays.scalars` 中解释。

- 如果选择元组的所有条目都是 ``:``，除了第 *p* 个条目是切片对象 ``i:j:k``，则返回的数组具有维度 *N*，通过沿第 *p* 轴堆叠由整数索引的元素 *i*、*i+k*、...、*i + (m - 1) k < j*返回的子数组形成。

- 基本切片在切片元组中具有多个非 ``:`` 条目时，作用类似于使用单个非 ``:`` 条目的切片重复应用，其中非 ``:`` 条目依次被取用（所有其他非 ``:`` 条目被替换为 ``:``）。因此，``x[ind1, ..., ind2,:]`` 在基本切片下作用类似于 ``x[ind1][..., ind2, :]``。

  .. warning:: 上述内容 **不适用于高级索引**。

- 您可以使用切片来设置数组中的值，但（与列表不同）您永远无法扩展数组。要在 ``x[obj] = value`` 中设置的值的大小必须（可广播到）与 ``x[obj]`` 的形状相同。

- 切片元组总是可以构造为 *obj* 并在 ``x[obj]`` 表示法中使用。切片对象可以在构造中代替 ``[start:stop:step]`` 表示法使用。例如，``x[1:10:5, ::-1]`` 也可以实现为 ``obj = (slice(1, 10, 5), slice(None, None, -1)); x[obj]``。这对于构建适用于任意维度数组的通用代码非常有用。有关更多信息，请参阅 :ref:`dealing-with-variable-indices`。

.. index::
   对: ndarray; 视图

.. _dimensional-indexing-tools:

维度索引工具
~~~~~~~~~~~~~~

有一些工具可以方便地匹配数组形状与表达式以及在赋值中的使用。

:py:data:`Ellipsis` 扩展为所需数量的 ``:`` 对象，以便选择元组索引所有维度。在大多数情况下，这意味着扩展后的选择元组的长度为 ``x.ndim``。只能存在一个省略号。
从上面的例子::

    >>> x[..., 0]
    array([[1, 2, 3],
          [4, 5, 6]])

这等价于::

    >>> x[:, :, 0]
    array([[1, 2, 3],
          [4, 5, 6]])

选择元组中的每个 :const:`newaxis` 对象用于将结果选择的维度扩展一个单位长度维度。添加的维度是 :const:`newaxis` 对象在选择元组中的位置。:const:`newaxis` 是 ``None`` 的别名，并且可以使用 ``None`` 代替它，结果相同。
从上面的例子::

    >>> x[:, np.newaxis, :, :].shape
    (2, 1, 3, 1)
    >>> x[:, None, :, :].shape
    (2, 1, 3, 1)

这可以方便地以某种方式组合两个数组，否则将需要显式的重塑操作。例如::

    >>> x = np.arange(5)
    >>> x[:, np.newaxis] + x[np.newaxis, :]
    array([[0, 1, 2, 3, 4],
          [1, 2, 3, 4, 5],
          [2, 3, 4, 5, 6],
          [3, 4, 5, 6, 7],
          [4, 5, 6, 7, 8]])


.. _advanced-indexing:

高级索引
---------

当选择对象 *obj* 是一个非元组序列对象、一个数据类型为整数或布尔的 :class:`ndarray`，或者是一个至少包含一个序列对象或数据类型为整数或布尔的 ndarray 的元组时，会触发高级索引。高级索引有两种类型：整数索引和布尔索引。

高级索引总是返回数据的 **副本** （与基本切片返回 :term:`视图` 形成对比）。

.. warning::

   高级索引的定义意味着 ``x[(1, 2, 3),]`` 与 ``x[(1, 2, 3)]`` 有本质上的不同。后者等价于 ``x[1, 2, 3]``，这将触发基本选择，而前者将触发高级索引。请务必理解为什么会发生这种情况。

整数数组索引
~~~~~~~~~~~~~~~~~~~~~~

整数数组索引允许基于数组的 *N* 维索引选择任意项。每个整数数组表示该维度中的多个索引。

索引数组中允许使用负值，其工作方式与单个索引或切片中的负值相同::

    >>> x = np.arange(10, 1, -1)
    >>> x
    array([10,  9,  8,  7,  6,  5,  4,  3,  2])
    >>> x[np.array([3, 3, 1, 8])]
    array([7, 7, 9, 2])
    >>> x[np.array([3, 3, -3, 8])]
    array([7, 7, 4, 2])

如果索引值超出范围，则会抛出 ``IndexError``::

    >>> x = np.array([[1, 2], [3, 4], [5, 6]])
    >>> x[np.array([1, -1])]
    array([[3, 4],
          [5, 6]])
    >>> x[np.array([3, 4])]
    Traceback (most recent call last):
      ...
    IndexError: index 3 is out of bounds for axis 0 with size 3

当索引由与被索引数组的维度数量相同的整数数组组成时，索引操作是直接的，但与切片不同。

高级索引总是 :ref:`广播<basics.broadcasting>` 并作为一个整体进行迭代::

     result[i_1, ..., i_M] == x[ind_1[i_1, ..., i_M], ind_2[i_1, ..., i_M],
                                ..., ind_N[i_1, ..., i_M]]

请注意，结果的形状与（广播后的）索引数组形状 ``ind_1, ..., ind_N`` 相同。如果索引无法广播到相同的形状，则会抛出异常 ``IndexError: shape mismatch: indexing arrays could not be broadcast together with shapes...``。

使用多维索引数组进行索引通常是较为不常见的用法，但它们是允许的，并且在某些问题中非常有用。我们从最简单的多维情况开始::

    >>> y = np.arange(35).reshape(5, 7)
    >>> y
    array([[ 0,  1,  2,  3,  4,  5,  6],
           [ 7,  8,  9, 10, 11, 12, 13],
           [14, 15, 16, 17, 18, 19, 20],
           [21, 22, 23, 24, 25, 26, 27],
           [28, 29, 30, 31, 32, 33, 34]])
    >>> y[np.array([0, 2, 4]), np.array([0, 1, 2])]
    array([ 0, 15, 30])

在这种情况下，如果索引数组具有匹配的形状，并且为被索引数组的每个维度都有一个索引数组，则结果数组的形状与索引数组相同，并且值对应于索引数组中每个位置的索引集。在这个例子中，第一个索引值对于两个索引数组都是 0，因此结果数组的第一个值是 ``y[0, 0]``。下一个值是 ``y[2, 1]``，最后一个是 ``y[4, 2]``。

如果索引数组没有相同的形状，则会尝试将它们广播到相同的形状。如果它们无法广播到相同的形状，则会抛出异常::

    >>> y[np.array([0, 2, 4]), np.array([0, 1])]
    Traceback (most recent call last):
      ...
    IndexError: shape mismatch: indexing arrays could not be broadcast
    together with shapes (3,) (2,)

广播机制允许索引数组与其他索引的标量组合。其效果是标量值用于索引数组的所有对应值::

    >>> y[np.array([0, 2, 4]), 1]
    array([ 1, 15, 29])

跳到下一个复杂级别，可以使用索引数组对数组进行部分索引。理解这种情况需要一些思考。例如，如果我们只使用一个索引数组与 y::

    >>> y[np.array([0, 2, 4])]
    array([[ 0,  1,  2,  3,  4,  5,  6],
           [14, 15, 16, 17, 18, 19, 20],
           [28, 29, 30, 31, 32, 33, 34]])

这将构造一个新数组，其中索引数组的每个值从被索引数组中选择一行，结果数组的形状为（索引元素的数量，行的大小）。

通常，结果数组的形状将是索引数组的形状（或所有索引数组广播到的形状）与被索引数组中未使用维度（未索引的维度）的形状的连接。

.. rubric:: 示例

从每一行中选择一个特定元素。行索引只是 ``[0, 1, 2]``，列索引指定要为相应行选择的元素，这里是 ``[0, 1, 0]``。将两者一起使用，可以使用高级索引解决任务::

    >>> x = np.array([[1, 2], [3, 4], [5, 6]])
    >>> x[[0, 1, 2], [0, 1, 0]]
    array([1, 4, 5])

要实现类似于基本切片的行为，可以使用广播。函数 :func:`ix_` 可以帮助进行这种广播。这最好通过一个例子来理解。

.. rubric:: 示例

从一个 4x3 数组中选择角元素，使用高级索引。因此，需要选择列是 ``[0, 2]`` 且行是 ``[0, 3]`` 的所有元素。要使用高级索引，需要显式选择所有元素。使用之前解释的方法，可以这样写::

    >>> x = np.array([[ 0,  1,  2],
    ...               [ 3,  4,  5],
    ...               [ 6,  7,  8],
    ...               [ 9, 10, 11]])
    >>> rows = np.array([[0, 0],
    ...                  [3, 3]], dtype=np.intp)
    >>> columns = np.array([[0, 2],
    ...                     [0, 2]], dtype=np.intp)
    >>> x[rows, columns]
    array([[ 0,  2],
           [ 9, 11]])

然而，由于上面的索引数组只是重复自身，可以使用广播（比较操作如 ``rows[:, np.newaxis] + columns``）来简化这个::

    >>> rows = np.array([0, 3], dtype=np.intp)
    >>> columns = np.array([0, 2], dtype=np.intp)
    >>> rows[:, np.newaxis]
    array([[0],
           [3]])
    >>> x[rows[:, np.newaxis], columns]
    array([[ 0,  2],
           [ 9, 11]])

这种广播也可以使用函数 :func:`ix_` 实现::

    >>> x[np.ix_(rows, columns)]
    array([[ 0,  2],
           [ 9, 11]])

请注意，如果没有 ``np.ix_`` 调用，只会选择对角线元素::

    >>> x[rows, columns]
    array([ 0, 11])

这种差异是记住使用多个高级索引进行索引时最重要的内容。

.. rubric:: 示例

高级索引可能在实际生活中的一个例子是颜色查找表，我们希望将图像的值映射到用于显示的 RGB 三元组。查找表可能具有形状 (nlookup, 3)。使用形状为 (ny, nx) 且 dtype=np.uint8 的图像（或任何整数类型，只要值在查找表的范围内）索引这样的数组，将生成形状为 (ny, nx, 3) 的数组，其中每个像素位置都关联一个 RGB 三元组。

.. _boolean-indexing:

布尔数组索引
~~~~~~~~~~~~~~~~~~~~~~

当 *obj* 是一个布尔类型的数组对象时，会发生这种高级索引，例如通过比较运算符返回的结果。一个单独的布尔索引数组实际上与 ``x[obj.nonzero()]`` 相同，其中，如上所述，:meth:`obj.nonzero() <ndarray.nonzero>` 返回一个元组（长度为 :attr:`obj.ndim <ndarray.ndim>`），包含显示 *obj* 中 :py:data:`True` 元素的整数索引数组。然而，当 ``obj.shape == x.shape`` 时，这种方式更快。

如果 ``obj.ndim == x.ndim``，``x[obj]`` 返回一个一维数组，填充了 *x* 中对应于 *obj* 的 :py:data:`True` 值的元素。搜索顺序将是 :term:`行优先`，C 风格的。如果 *obj* 的形状与 *x* 的相应维度不匹配，无论这些值是 :py:data:`True` 还是 :py:data:`False`，都会引发索引错误。

一个常见的用例是通过布尔索引来过滤所需的元素值。例如，可能希望从数组中选择所有不是 :const:`numpy.nan` 的条目::

    >>> x = np.array([[1., 2.], [np.nan, 3.], [np.nan, np.nan]])
    >>> x[~np.isnan(x)]
    array([1., 2., 3.])

或者希望将所有负元素加上一个常数::

    >>> x = np.array([1., -1., -2., 3])
    >>> x[x < 0] += 20
    >>> x
    array([ 1., 19., 18., 3.])

通常，如果索引包含一个布尔数组，结果将与在相同位置插入 ``obj.nonzero()`` 并使用上述整数数组索引机制相同。``x[ind_1, boolean_array, ind_2]`` 等价于 ``x[(ind_1,) + boolean_array.nonzero() + (ind_2,)]``。

如果只有一个布尔数组而没有整数索引数组，这是直接的。只需要确保布尔索引的维度与它应该工作的维度完全相同。

通常，当布尔数组的维度少于被索引的数组时，这等价于 ``x[b, ...]``，这意味着 x 由 b 索引，后面跟着足够多的 ``:`` 以填充 x 的秩。因此，结果的形状是一个维度，包含布尔数组中 :py:data:`True` 元素的数量，后面跟着被索引数组的剩余维度::

    >>> x = np.arange(35).reshape(5, 7)
    >>> b = x > 20
    >>> b[:, 5]
    array([False, False, False,  True,  True])
    >>> x[b[:, 5]]
    array([[21, 22, 23, 24, 25, 26, 27],
          [28, 29, 30, 31, 32, 33, 34]])

这里，索引数组的第 4 行和第 5 行被从被索引数组中选择出来，并组合成一个二维数组。

.. rubric:: 示例

从一个数组中选择所有行，这些行的总和小于或等于 2::

    >>> x = np.array([[0, 1], [1, 1], [2, 2]])
    >>> rowsum = x.sum(-1)
    >>> x[rowsum <= 2, :]
    array([[0, 1],
           [1, 1]])

结合多个布尔索引数组或布尔数组与整数索引数组可以通过 :meth:`obj.nonzero() <ndarray.nonzero>` 的类比来理解。函数 :func:`ix_` 也支持布尔数组，并且不会出现任何意外。

.. rubric:: 示例

使用布尔索引来选择所有行，这些行的总和为偶数。同时，使用高级整数索引来选择第 0 列和第 2 列。使用 :func:`ix_` 函数可以这样做::

    >>> x = np.array([[ 0,  1,  2],
    ...               [ 3,  4,  5],
    ...               [ 6,  7,  8],
    ...               [ 9, 10, 11]])
    >>> rows = (x.sum(-1) % 2) == 0
    >>> rows
    array([False,  True, False,  True])
    >>> columns = [0, 2]
    >>> x[np.ix_(rows, columns)]
    array([[ 3,  5],
           [ 9, 11]])

如果没有 ``np.ix_`` 调用，只会选择对角线元素。

或者没有 ``np.ix_`` （比较整数数组示例）::

    >>> rows = rows.nonzero()[0]
    >>> x[rows[:, np.newaxis], columns]
    array([[ 3,  5],
           [ 9, 11]])

.. rubric:: 示例

使用形状为 (2, 3) 的二维布尔数组，其中有四个 :py:data:`True` 元素，从形状为 (2, 3, 5) 的三维数组中选择行，结果是一个形状为 (4, 5) 的二维数组::

    >>> x = np.arange(30).reshape(2, 3, 5)
    >>> x
    array([[[ 0,  1,  2,  3,  4],
            [ 5,  6,  7,  8,  9],
            [10, 11, 12, 13, 14]],
          [[15, 16, 17, 18, 19],
            [20, 21, 22, 23, 24],
            [25, 26, 27, 28, 29]]])
    >>> b = np.array([[True, True, False], [False, True, True]])
    >>> x[b]
    array([[ 0,  1,  2,  3,  4],
          [ 5,  6,  7,  8,  9],
          [20, 21, 22, 23, 24],
          [25, 26, 27, 28, 29]])

.. _combining-advanced-and-basic-indexing:

结合高级和基本索引
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

当索引中至少有一个切片 (``:``)、省略号 (``...``) 或 :const:`newaxis` 时（或者数组的维度多于高级索引的数量），行为可能会更加复杂。这类似于为每个高级索引元素连接索引结果。

在最简单的情况下，只有一个高级索引与一个切片结合。例如::

    >>> y = np.arange(35).reshape(5,7)
    >>> y[np.array([0, 2, 4]), 1:3]
    array([[ 1,  2],
           [15, 16],
           [29, 30]])

实际上，切片和索引数组的操作是独立的。切片操作提取索引为 1 和 2 的列（即第 2 列和第 3 列），然后索引数组操作提取索引为 0、2 和 4 的行（即第 1 行、第 3 行和第 5 行）。这等价于::

    >>> y[:, 1:3][np.array([0, 2, 4]), :]
    array([[ 1,  2],
           [15, 16],
           [29, 30]])

一个单独的高级索引可以替换一个切片，结果数组将是相同的。然而，它是一个副本，可能具有不同的内存布局。在可能的情况下，切片是更好的选择。例如::

    >>> x = np.array([[ 0,  1,  2],
    ...               [ 3,  4,  5],
    ...               [ 6,  7,  8],
    ...               [ 9, 10, 11]])
    >>> x[1:2, 1:3]
    array([[4, 5]])
    >>> x[1:2, [1, 2]]
    array([[4, 5]])

理解多个高级索引的组合的最简单方法是考虑结果的形状。索引操作有两个部分：由基本索引（不包括整数）定义的子空间和高级索引部分定义的子空间。需要区分两种索引组合的情况：

* 高级索引由切片、:py:data:`Ellipsis` 或 :const:`newaxis` 分隔。例如 ``x[arr1, :, arr2]``。
* 高级索引彼此相邻。例如 ``x[..., arr1, arr2, :]``，但不是 ``x[arr1, :, 1]``，因为 ``1`` 在这种情况下是一个高级索引。

在第一种情况下，高级索引操作产生的维度在结果数组中排在最前面，然后是子空间的维度。在第二种情况下，高级索引操作的维度插入到结果数组中与它们在初始数组中相同的位置（后者的逻辑使得简单的高级索引行为类似于切片）。

.. rubric:: 示例

假设 ``x.shape`` 是 (10, 20, 30)，``ind`` 是一个形状为 (2, 5, 2) 的索引 :class:`intp` 数组，那么 ``result = x[..., ind, :]`` 的形状是 (10, 2, 5, 2, 30)，因为 (20,) 形状的子空间被替换为一个 (2, 5, 2) 形状的广播索引子空间。如果我们让 *i, j, k* 遍历 (2, 5, 2) 形状的子空间，那么 ``result[..., i, j, k, :] = x[..., ind[i, j, k], :]``。这个例子产生的结果与 :meth:`x.take(ind, axis=-2) <ndarray.take>` 相同。

.. rubric:: 示例

设 ``x.shape`` 为 (10, 20, 30, 40, 50)，假设 ``ind_1`` 和 ``ind_2`` 可以广播到形状 (2, 3, 4)。那么 ``x[:, ind_1, ind_2]`` 的形状是 (10, 2, 3, 4, 40, 50)，因为 X 中的 (20, 30) 形状的子空间被索引中的 (2, 3, 4) 子空间替换。然而，``x[:, ind_1, :, ind_2]`` 的形状是 (2, 3, 4, 10, 30, 50)，因为索引子空间没有明确的位置可以插入，因此它被附加到开头。总是可以使用 :meth:`.transpose() <ndarray.transpose>` 将子空间移动到任何期望的位置。请注意，这个例子不能使用 :func:`take` 复制。

.. rubric:: 示例

切片可以与广播的布尔索引结合使用::

    >>> x = np.arange(35).reshape(5, 7)
    >>> b = x > 20
    >>> b
    array([[False, False, False, False, False, False, False],
          [False, False, False, False, False, False, False],
          [False, False, False, False, False, False, False],
          [ True,  True,  True,  True,  True,  True,  True],
          [ True,  True,  True,  True,  True,  True,  True]])
    >>> x[b[:, 5], 1:3]
    array([[22, 23],
          [29, 30]])


.. _arrays.indexing.fields:

字段访问
--------

.. seealso:: :ref:`structured_arrays`

如果 :class:`ndarray` 对象是一个结构化数组，可以通过字符串索引（类似字典的方式）来访问数组的 :term:`字段 <field>`。

索引 ``x['field-name']`` 返回一个新的 :term:`视图`，其形状与 *x* 相同（除非该字段是一个子数组），但数据类型为 ``x.dtype['field-name']``，并且仅包含指定字段中的数据。此外，:ref:`记录数组 <arrays.classes.rec>` 标量也可以通过这种方式进行“索引”。

对结构化数组的索引也可以通过字段名称列表来完成，例如 ``x[['field-name1', 'field-name2']]``。从 NumPy 1.16 开始，这将返回一个仅包含这些字段的视图。在旧版本的 NumPy 中，它返回的是一个副本。有关多字段索引的更多信息，请参阅用户指南中的 :ref:`structured_arrays` 部分。

如果访问的字段是一个子数组，则子数组的维度将附加到结果的形状中。例如：


>>> x = np.zeros((2, 2), dtype=[('a', np.int32), ('b', np.float64, (3, 3))])
>>> x['a'].shape
(2, 2)
>>> x['a'].dtype
dtype('int32')
>>> x['b'].shape
(2, 2, 3, 3)
>>> x['b'].dtype
dtype('float64')

.. _flat-iterator-indexing:

扁平迭代器索引
--------------

:attr:`x.flat <ndarray.flat>` 返回一个迭代器，该迭代器将遍历整个数组（以 C 连续风格遍历，最后一个索引变化最快）。这个迭代器对象也可以使用基本切片或高级索引进行索引，只要选择对象不是元组即可。这应该很清楚，因为 :attr:`x.flat <ndarray.flat>` 是一个一维视图。它可以用于使用一维 C 风格扁平索引的整数索引。因此，任何返回数组的形状都是整数索引对象的形状。

.. index::
   single: indexing
   single: ndarray


.. _assigning-values-to-indexed-arrays:

为索引数组赋值
--------------

如前所述，可以使用单个索引、切片以及索引和掩码数组来选择数组的子集进行赋值。被赋值给索引数组的值必须与索引生成的形状一致（即具有相同的形状或可以广播到该形状）。例如，可以将常量赋值给切片：


>>> x = np.arange(10)
>>> x[2:7] = 1


或者赋值一个正确大小的数组：


>>> x[2:7] = np.arange(5)


请注意，赋值可能会导致类型转换（例如将浮点数赋值给整数），甚至可能引发异常（例如将复数赋值给浮点数或整数）：


>>> x[1] = 1.2
>>> x[1]
1
>>> x[1] = 1.2j  # doctest: +IGNORE_EXCEPTION_DETAIL
Traceback (most recent call last):
  ...
TypeError: can't convert complex to int


与某些引用（如数组和掩码索引）不同，赋值总是直接作用于原始数组中的数据（毕竟，其他方式也没有意义！）。不过，有些操作可能不会像人们天真地期望的那样工作。这个特定的例子常常让人感到惊讶：

>>> x = np.arange(0, 50, 10)
>>> x
array([ 0, 10, 20, 30, 40])
>>> x[np.array([1, 1, 3, 1])] += 1
>>> x
array([ 0, 11, 20, 31, 40])

人们可能期望第一个位置会被增加 3 次。但实际上，它只会被增加 1 次。原因是：从原始数组中提取了一个新的数组（作为临时数组），包含位置 1, 1, 3, 1 的值，然后将值 1 添加到这个临时数组中，最后将临时数组赋值回原始数组。因此，数组在 ``x[1] + 1`` 处的值被赋值给 ``x[1]`` 三次，而不是被增加 3 次。

.. _dealing-with-variable-indices:

处理程序中可变数量的索引
--------------------------------------------------------

索引语法非常强大，但在处理可变数量的索引时会受到限制。例如，如果你想编写一个函数，该函数可以处理具有不同维度的参数，而不必为每种可能的维度编写特殊情况的代码，那么该如何实现呢？如果你将一个元组提供给索引，该元组将被解释为索引列表。例如：：

 >>> z = np.arange(81).reshape(3, 3, 3, 3)
 >>> indices = (1, 1, 1, 1)
 >>> z[indices]
 40

因此，可以使用代码构造任意数量的索引元组，然后在索引中使用这些元组。

可以通过在 Python 中使用 `slice()` 函数在程序中指定切片。例如：：

 >>> indices = (1, 1, 1, slice(0, 2))  # 等同于 [1, 1, 1, 0:2]
 >>> z[indices]
 array([39, 40])

同样，可以通过代码使用 `Ellipsis` 对象指定省略号：：

 >>> indices = (1, Ellipsis, 1)  # 等同于 [1, ..., 1]
 >>> z[indices]
 array([[28, 31, 34],
        [37, 40, 43],
        [46, 49, 52]])

因此，可以直接使用 `np.nonzero() <ndarray.nonzero>` 函数的输出作为索引，因为它总是返回一个索引数组的元组。

由于元组的特殊处理，它们不会像列表那样自动转换为数组。例如：：

 >>> z[[1, 1, 1, 1]]  # 生成一个大型数组
 array([[[[27, 28, 29],
          [30, 31, 32], ...
 >>> z[(1, 1, 1, 1)]  # 返回单个值
 40


详细说明
--------------

以下是一些详细说明，对于日常索引来说并不重要（顺序不分先后）：

* NumPy 的原生索引类型是 `intp`，可能与默认的整数数组类型不同。`intp` 是能够安全索引任何数组的最小数据类型；对于高级索引，它可能比其他类型更快。
* 对于高级赋值，通常无法保证迭代顺序。这意味着如果一个元素被设置了多次，无法预测最终结果。
* 空元组索引是对零维数组的完全标量索引。`x[()]` 如果 `x` 是零维数组，则返回一个标量，否则返回一个视图。另一方面，`x[...]` 总是返回一个视图。
* 如果索引中存在零维数组并且它是完全整数索引，结果将是一个标量而不是零维数组。（不会触发高级索引。）
* 当存在省略号（`...`）但没有大小（即替换零个 `:`）时，结果仍然总是一个数组。如果没有高级索引，则返回视图，否则返回副本。
* 布尔数组的 `nonzero` 等价性不适用于零维布尔数组。
* 当高级索引操作的结果没有元素但单个索引超出边界时，是否引发 `IndexError` 是未定义的（例如 `x[[], [123]]`，其中 `123` 超出边界）。
* 当在赋值期间发生类型转换错误时（例如使用字符串序列更新数值数组），被赋值的数组可能会处于不可预测的部分更新状态。然而，如果发生任何其他错误（例如索引超出边界），数组将保持不变。
* 高级索引结果的内存布局针对每个索引操作进行了优化，无法假设特定的内存顺序。
* 当使用子类（特别是操作其形状的子类）时，默认的 `ndarray.__setitem__` 行为会为基本索引调用 `__getitem__`，但不会为高级索引调用。对于这样的子类，最好使用数据上的基类 `ndarray` 视图调用 `ndarray.__setitem__`。如果子类的 `__getitem__` 不返回视图，则必须这样做。